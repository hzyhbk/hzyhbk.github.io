{"meta":{"title":"hzyhbk","subtitle":null,"description":null,"author":null,"url":"http://hzyhbk.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-28T09:13:16.961Z","updated":"2019-12-28T09:13:16.961Z","comments":true,"path":"404.html","permalink":"http://hzyhbk.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"tags","date":"2019-12-28T07:14:53.000Z","updated":"2019-12-28T10:21:28.782Z","comments":true,"path":"archives/index.html","permalink":"http://hzyhbk.github.io/archives/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-12-28T10:22:07.200Z","updated":"2019-12-28T10:22:07.200Z","comments":true,"path":"about/index.html","permalink":"http://hzyhbk.github.io/about/index.html","excerpt":"","text":"介绍自己 我叫慌张 杭州电子科技大学-软件工程专业-2019级毕业生 杭州大搜车-无线开发部-前端开发工程师 关于主题本站主题是：Material XMac用户可以下载客户端哦： MaterialX-Installer.dmg"},{"title":"categories","date":"2019-12-28T07:14:03.000Z","updated":"2019-12-28T07:14:22.313Z","comments":true,"path":"categories/index.html","permalink":"http://hzyhbk.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-28T07:14:53.000Z","updated":"2019-12-28T07:15:02.644Z","comments":true,"path":"tags/index.html","permalink":"http://hzyhbk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"antd表格合并单元格，并且支持导出excel","slug":"start/export-excel","date":"2020-01-07T11:48:09.000Z","updated":"2020-01-08T12:49:37.497Z","comments":true,"path":"start/export-excel/","link":"","permalink":"http://hzyhbk.github.io/start/export-excel/","excerpt":"最近接到个报表的需求，需要展示合并单元格的表格，并且还要支持导出excel。粗略一看，不就两个功能嘛，但是在实现的过程中发现其实要做的还是挺多的，所以在这里记录分享一下。 一、合并单元格的实现","text":"最近接到个报表的需求，需要展示合并单元格的表格，并且还要支持导出excel。粗略一看，不就两个功能嘛，但是在实现的过程中发现其实要做的还是挺多的，所以在这里记录分享一下。 一、合并单元格的实现 合并单元格这个功能的实现用的是antd的table组件。下面是antd-table组件行列合并功能的使用介绍： 表格支持行/列合并，使用 render 里的单元格属性 colSpan 或者 rowSpan 设值为 0 时，设置的表格不会渲染。 光看这句话好像还不太好理解，看下官方例子的代码就好理解多了。123456789101112131415161718&#123; title: 'Name', dataIndex: 'name', render: (text, row, index) =&gt; &#123; const obj = &#123; children: text, props: &#123;&#125;, &#125;; if (index === 2) &#123; obj.props.rowSpan = 2; &#125; // These two are merged into above cell if (index === 3) &#123; obj.props.rowSpan = 0; &#125; return obj; &#125;,&#125;, 我来解读一下上面这一项的意思：当 index === 2，把这一行的 rowSpan 设置为2，也就是第三条数据的时候，这一个单元格需要占两格，那么对应的它后面的一行，也就是 index === 3 这一行就只能占0格了，也就是需要把index === 3时候的 rowSpan设置为0。 了解了antd-table组件怎么设置单元格合并，下面就可以开始实现了。无非就是计算一下每一列里，每一项出现的次数，然后再设置下 rowSpan 的值就好了。但是在开始计算之前，还需要做一些准备工作： 后端在返回数据的时候是通过 树形结构 返回的，而渲染表格用到的数据是 数组 的形式，所以我需要手动先转化一遍数据； 其次还要对数据按照表格每一列来排一次序，至于为什么排序，后面再说 1. 处理原始数据后端返回的数据是这样子的：123456789101112131415161718192021const mockData = [&#123; children: [&#123; children: [&#123; children: [], rate: 0.3333333333333333, name: '需求1', cost: 3, id: 5, projectId: 1, projectName: 'test1', assigner: '张三', &#125;], name: '迭代一', rate: 0.75, cost: 9, id: 2, &#125;], name: '项目一', cost: 12, id: 1,&#125;]; 上面的数据层级有三级，表示的含义就是表格至少会有三列，而且前三列的数据是需要做合并单元格操作的。树形结构数据首先就想到了用递归的方式，因此我需要通过递归来把这种类型的数据给拍平成数组，并且拿到每一级的信息。下面是我拍平之后的结果（firstColName、secondColName、thirdColName 就是表格的列标题，也可以是表格每一列的dataIndex字段，这里为了省事，我直接拿列标题来用了）。123456789101112131415161718192021222324252627const flatMockData = [ &#123; firstColName: &#123; name: '项目一', cost: 12, id: 1, children: //... &#125;, secondColName: &#123; name: '迭代一', rate: 0.75, cost: 9, id: 2, children: //... &#125;, thirdColName: &#123; rate: 0.3333333333333333, name: '需求一', cost: 3, id: 5, projectId: 1, projectName: 'test1', assigner: '张三', children: //..., &#125; &#125;,] 要让 树形结构每一级 和 表格的每一列 对应起来，原始数据肯定是不够的，还需要额外一个参数来表示每一级的深度，这样我就能把每一级的数据和表格列名对应起来。 1.1 树形结构数据加上层级参数这一步很好实现，一个递归就好了，直接上代码。12345678910function addDeepsToTreeData( data: ITreeDataItem[], depsNum: number = 0,): ITreeDataDepsItem[] &#123; return data.map(item =&gt; (&#123; ...item, __deps: depsNum, // 表示层级的参数 children: addDeepsToTreeData(item.children, depsNum + 1), &#125;));&#125; 1.2 拍平树形结构数据因为之前我们已经给树形结构的每一层都加了表示层级的参数，这样做就是为了在拍平数据这一步的时候能很快和表格的列名对应起来。1234567891011121314151617181920212223242526272829303132const colNameList = ['firstColName', 'secondColName', 'thirdColName'];function getFlatData(data: ITreeDepsDataItem[], colNameList: string[]) &#123; let array: &#123; [k: string]: ITreeDepsDataItem &#125;[] = []; function convert( data: ITreeDepsDataItem[], parentItem: &#123; [k: string]: any &#125; = &#123;&#125;, // 上一级的信息 ) &#123; _.forEach(data, item =&gt; &#123; if (item.children &amp;&amp; item.children.length !== 0) &#123; if (parentItem) &#123; // 如果自己的children不为空，并且有上几级信息 // 就加上自己这一级的信息，继续往下传递 convert(item.children, &#123; ...parentItem, [colNameList[item.__deps]]: item, &#125;); &#125; else &#123; // 如果自己的children不为空 ，但是没有上几级的信息没有上一级信息 // 就把自己这一级的信息传递下去 convert(item.children, &#123; [colNameList[item.__deps]]: item &#125;); &#125; &#125; else &#123; // children为空说明走到最后一级了 // 这时，表格一行里所有列的数据都获取到了，就push到临时数组里 array.push(&#123; ...parentItem,[colNameList[item.__deps]]: item, &#125;); &#125; &#125;); &#125; convert(data); return array;&#125;; 1.3 排序拍平之后的数组比如最后的表格有三列需要合并单元格，每一行就要根据这三列综合来排序；最后的表格有n列需要合并单元格，那么每一行就要根据这n列综合来排序，这样做是为了保证合并的都是重复出现的单元格。12345678910111213141516171819202122232425262728293031323334353637383940// 获取单个条件的排序函数type BooleanFn&lt;T&gt; = (x: T, y: T) =&gt; boolean;function getSort&lt;T&gt;(fn: BooleanFn&lt;T&gt;) &#123; return function(a: T, b: T) &#123; let ret = 0; if (fn.call(this, a, b)) &#123; ret = -1; &#125; else if (fn.call(this, b, a)) &#123; ret = 1; &#125; return ret; &#125;;&#125;// 获取多个条件的排序函数type NumberFn&lt;T&gt; = (x: T, y: T) =&gt; number;function getMutipSort&lt;T&gt;(arr: NumberFn&lt;T&gt;[]) &#123; return function(a: T, b: T) &#123; let tmp, i = 0; do &#123; tmp = arr[i++](a, b); &#125; while (tmp == 0 &amp;&amp; i &lt; arr.length); return tmp; &#125;;&#125;// 根据多个条件排序数据function getSortableData(flatData: &#123; [k: string]: ITreeDepsDataItem &#125;[],colNameList: string[]) &#123; const sortableData = _.cloneDeep(flatData); const sortArr = colNameList.map(item =&gt; getSort&lt;&#123; [k: string]: ITreeDepsDataItem &#125;&gt;((a, b) =&gt; &#123; if (a[item] &amp;&amp; b[item]) &#123; return a[item].name.toUpperCase() &lt; b[item].name.toUpperCase(); &#125; return false; &#125;), ); sortableData.sort(getMutipSort(sortArr)); return sortableData;&#125; 到这里，数据就已经处理好了。下面就是计算每一行下面每一个单元格出现的次数 2. 计算每一行里每个单元格出现的次数循环排好序的数据，计算一行里所有单元格的重复次数（以 ${name}_${id} 作为数据的唯一标识，只用 id 做唯一标识也可以），并把结果存在以 这一行里第一个单元格数据的唯一标识 作为key的对象中。这句话可能有点不好理解，所以我用下面的数据来解释下123456789101112131415161718192021// 假设这是已经排好序的数据const sortableData = [&#123; firstColName: &#123; name: '项目一', id: 1, cost: 12, children: [] &#125;, secondColName: &#123; name: '迭代一', id: 2, rate: 0.75, cost: 9, children: [] &#125;, thirdColName: &#123; name: '需求一', id: 5, rate: 0.25, cost: 3, projectId: 1, projectName: '项目一', assigner: '张三', children: [], &#125;&#125;,&#123; firstColName: &#123; name: '项目一', id: 1, cost: 12, children: [] &#125;, secondColName: &#123; name: '迭代一', id: 2, rate: 0.75, cost: 9, children: [] &#125;, thirdColName: &#123; name: '需求二', id: 6, rate: 0.25, cost: 3, projectId: 1, projectName: '项目一', assigner: '李四', children: [], &#125;&#125;];// 计算之后的重复次数就是这样// 这个重复出现的次数就是后面 render 函数返回的 rowSpan 的值。const cellRepetitions = &#123; 项目一_1: &#123; 项目一_1: 2, 迭代一_2: 2, 需求一_5: 1, 需求二_6: 1, &#125;&#125; 下面是计算重复次数的函数123456789101112131415161718192021222324252627282930// 获取每一组数据里重复出现的数据的次数type IObjNumber = &#123; [k: string]: number &#125;;function getCellRepetitions(sortableData:&#123; [k: string]: ITreeDepsDataItem &#125;[], colNameList: string[]) &#123; // 表格第一列的列名 const parentColName = colNameList[0]; const cellRepetitions: &#123; [k: string]: IObjNumber | number; &#125; = &#123;&#125;; // 循环排好序的数据，item代表每一行 _.forEach(sortableData, item =&gt; &#123; const parentColVal = `$&#123;item[parentColName].name&#125;_$&#123;item[parentColName].id&#125;`; if (!cellRepetitions[parentColVal]) &#123; cellRepetitions[parentColVal] = &#123;&#125;; &#125; // 循环列名，item[col]代表这一行里每一个单元格 _.forEach(colNameList, col =&gt; &#123; if (item[col]) &#123; const colValue = `$&#123;item[col].name&#125;_$&#123;item[col].id&#125;`; cellRepetitions[`__dot_$&#123;col&#125;`] = 0; //后面在render的时候会用到的标志位 if ((cellRepetitions[parentColVal] as IObjNumber)[colValue]) &#123; (cellRepetitions[parentColVal] as IObjNumber)[colValue]++; &#125; else &#123; (cellRepetitions[parentColVal] as IObjNumber)[colValue] = 1; &#125; &#125; &#125;); &#125;); return cellRepetitions;&#125; 3. render函数计算好了重复次数之后，下面就可以写列的 render 函数了。12345678910// 以下是使用自己封装的 renderContent 的例子// renderContent 函数接收三个参数// 第一个参数是 antd-table 原始render函数的所有参数// 第二个参数是列名// 第三个参数为可选参数，不传的话默认返回name字段的值，传了的话就可以自定义返回内容&#123; name: 'colName', dataIndex: 'colName', render: (...rest) =&gt; renderContent(rest, 'colName'),&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 获取表格每项的render函数function getRenderContent(cellRepetitions: &#123; [k: string]: IObjNumber | number; &#125;, colNameList: string[]) &#123; const parentColName = colNameList[0]; // 这里需要实时修改前面留下的 __dot标志位，所以先拷贝一份数据 const countObj = _.cloneDeep(cellRepetitions); const renderContent: IRenderContent = ( rest: any, name: string, userRenderText?: IRenderText, // 自定义表格返回什么格式的数据 ) =&gt; &#123; const [v, row, index] = rest; const textForRender = userRenderText ? userRenderText(row) : v.name; const obj: &#123; children: string; props: &#123; rowSpan?: number &#125;; &#125; = &#123; children: textForRender, props: &#123;&#125;, &#125;; // 有 v 说明是需要合并的列 if (v) &#123; const value = `$&#123;v.name&#125;_$&#123;v.id&#125;`; const parentColVal = `$&#123;row[parentColName].name&#125;_$&#123;row[parentColName].id&#125;`; if (countObj[parentColVal]) &#123; /** * index表示第几行的数据 * 当 行数 等于 这一列的标志位 的时候，说明这一个单元格是需要被显示的 * 所以把这一个单元格的 rowspan 设置为它的重复次数 * * 并且这时更新标志位的数值，加上当前单元格的重复次数 * 后面当 行数 小于 这一列标志位 的时候，说明这一个单元格是需要被隐藏的， * 这时把 rowSpan 设置为 0 */ if (index === countObj[`__dot_$&#123;name&#125;`]) &#123; obj.props.rowSpan = (countObj[parentColVal] as IObjNumber)[value]; (countObj[`__dot_$&#123;name&#125;`] as number) += (countObj[ parentColVal ] as IObjNumber)[value]; &#125; else if (index &lt; countObj[`__dot_$&#123;name&#125;`]) &#123; obj.props.rowSpan = 0; &#125; &#125; &#125; return obj; &#125;; return renderContent;&#125; 以上，终于把表格合并单元格功能给完成了。下面就可以愉快的开始想怎么解决导出excel了。 二、 导出excel功能的实现导出excel功能使用的是 SheetJS 这个库。 并且参考了这位大佬的文章 http://blog.haoji.me/js-excel.html 遇到的坑点就是，js-xlsx 默认不支持设置样式。但是经过一番查找，发现了一个叫 xlsx-style 的库，使用这个库就可以给导出的excel设置样式。 通过dom节点导出具体的使用方式如下： 下载 js-xlsx/dist/xlsx.full.min.js 到项目中； 下载 xlsx-style/dist/xlsx.full.min.js 到项目中； 修改 xlsx-style/dist/xlsx.full.min.js 中的 XLSX 变量 为XLSX_STYLE，因为两个文件都是默认设置全局变量 XLSX，而我们只需要在最后导出的时候使用 xlsx-style 提供的方法，而其他工具方法还是使用 js-xlsx 中的； 在项目的index.html中引入这两个文件； js-xlsx 支持从dom节点导出excel，所以方便起见直接用dom节点导出。 12const dom = document.querySelector('.ant-table-body');const sheets = XLSX.utils.table_to_book(dom).Sheets.Sheet1; 给 sheet 设置样式，下面给出我的设置作为参考，更多设置请自行参考 xlsx-style#cell-styles 12345678910111213141516171819202122232425262728function setSheetStyle(sheet: ISheet, colNameList:string[]) &#123; // 设置列宽 sheet['!cols'] = colNameList.map(item =&gt; (&#123; wpx: 200 &#125;)); Object.keys(sheet).forEach(key =&gt; &#123; if (typeof sheet[key] === 'object') &#123; // 第一行是标题行 if (/^[A-Z]+1$/.test(key)) &#123; sheet[key].s = &#123; font: &#123; sz: 18, // 字体大小为18px bold: true,// 加粗 &#125;, alignment: &#123; vertical: 'center', // 垂直居中 wrapText: true, // 自动换行 &#125;, &#125;; &#125; else &#123; sheet[key].s = &#123; alignment: &#123; vertical: 'center', wrapText: true, &#125;, &#125;; &#125; &#125; &#125;);&#125; 在 sheet2blob 这个方法中 调用 XLSX_STYLE.write 方法来创建 workbook，上面一步设置的样式才会生效。 12345678910111213141516171819202122232425262728function sheet2blob(sheet: ISheet, name?: string) &#123; const sheetName = name || 'sheet1'; const workbook: &#123; SheetNames: string[]; Sheets: &#123; [k: string]: any &#125;; //多个sheet &#125; = &#123; SheetNames: [sheetName], Sheets: &#123;&#125;, &#125;; workbook.Sheets[sheetName] = sheet; // 生成excel的配置项 var wopts = &#123; bookType: 'xlsx', // 要生成的文件类型 bookSST: false, // 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性 type: 'binary', &#125;; // 这里调用 XLSX_STYLE 的 write 方法 const wbout = XLSX_STYLE.write(workbook, wopts); const blob = new Blob([s2ab(wbout)], &#123; type: 'application/octet-stream' &#125;); // 字符串转ArrayBuffer function s2ab(s: any) &#123; const buf = new ArrayBuffer(s.length); const view = new Uint8Array(buf); for (let i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff; return buf; &#125; return blob;&#125; 导出excel文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 通用的打开下载对话框方法，没有测试过具体兼容性 * @param url 下载地址，也可以是一个blob对象，必选 * @param saveName 保存文件名，可选 */function openDownloadDialog(url: string | Blob, saveName?: string) &#123; if (typeof url == 'object' &amp;&amp; url instanceof Blob) &#123; url = URL.createObjectURL(url); // 创建blob地址 &#125; let aLink = document.createElement('a'); aLink.href = url; aLink.download = saveName || ''; // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，file:///模式下不会生效 let event; if (window.MouseEvent) &#123; event = new MouseEvent('click'); &#125; else &#123; event = document.createEvent('MouseEvents'); event.initMouseEvent( 'click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null, ); &#125; aLink.dispatchEvent(event);&#125;function downloadExcelWithDom(dom: HTMLTableElement, saveName?: string) &#123; const fileName = `$&#123;saveName&#125;.xlsx` || '导出.xlsx'; const sheet = XLSX.utils.table_to_book(dom).Sheets.Sheet1; setSheetStyle(sheet); openDownloadDialog(sheet2blob(sheet), fileName);&#125; 以上就完成了导出excel功能。由于兼容性问题，有些浏览器上可能无法通过dom节点导出，这时候就只能自己设置数据来导出了。下面也讲讲怎么通过自己设置数据来导出。 通过数据导出 使用 XLSX.utils.aoa_to_sheet 方法来生成sheet，这个方法可以将一个二维数组转成sheet格式 12345678910111213141516171819function getSheetData(sortableData:&#123; [k: string]: ITreeDepsDataItem &#125;[], colNameList: string[]) &#123; let aoa: string[][] = []; aoa.push(colNameList); sortableData.forEach(item =&gt; &#123; aoa.push( // 这里只是简单的把单元格的内容设置为name属性 // 如果需要自定义单元格内容的话，可以使用 table 组件里设置好的 columns colNameList.map(colName =&gt; &#123; if (item[colName]) &#123; return item[colName].name; &#125; else &#123; const lastColName = colNameList[Object.keys(item).length - 1]; return (item[lastColName] as any)[colName] || '-'; &#125; &#125;), ); &#125;); return XLSX.utils.aoa_to_sheet(aoa);&#125; 循环表格的列跟行，计算需要合并的单元格，核心逻辑和和前面说的 renderContent 方法是相同的。单元格的合并需要设置 sheet[!merges]，格式如下 12345678910111213141516// 表示从 第0行第0列 到 第0行第2列 的单元格合并// 也就是第0行前三个单元格合并sheet[!merges] = [ &#123; // 表示start= s:&#123; r: 0, // 表示row c: 0, // 表示col的 &#125;, // 表示end e:&#123; r: 0, c: 2 &#125; &#125;] 下面是获取每一行需要合并的s和e 1234567891011121314151617181920_.forEach(colNameList, (item, colIndex) =&gt; &#123; _.forEach(sortableData, (row, rowIndex) =&gt; &#123; // getRepeatNum 方法同 renderContent，repeat就相当于rowSpan const repeat = getRepeatNum(row[item], row, rowIndex, item); // 只对 repeat 大于1 的单元格处理 // 并且这里列是固定的，只有行会发生合并，所以会简单一点 if (repeat &gt; 1) &#123; sheetMerges.push(&#123; s: &#123; r: rowIndex + 1, // 多了标题栏 所以要加 1 c: colIndex, &#125;, e: &#123; r: rowIndex + repeat - 1 + 1, // 多了标题栏 所以要加 1 c: colIndex, &#125;, &#125;); &#125; &#125;);&#125;); 最后 设置样式 和 导出 这两步和上面通过dom节点导出一样，不再赘述。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://hzyhbk.github.io/categories/web前端/"}],"tags":[{"name":"antd-table","slug":"antd-table","permalink":"http://hzyhbk.github.io/tags/antd-table/"},{"name":"js-xlsx","slug":"js-xlsx","permalink":"http://hzyhbk.github.io/tags/js-xlsx/"},{"name":"react","slug":"react","permalink":"http://hzyhbk.github.io/tags/react/"}]},{"title":"2020年元旦快乐","slug":"start/happy-2020","date":"2020-01-01T04:52:12.000Z","updated":"2020-01-01T05:13:19.608Z","comments":true,"path":"start/happy-2020/","link":"","permalink":"http://hzyhbk.github.io/start/happy-2020/","excerpt":"2020年元旦快乐！ 2020年第一天，给博客换了个logo，顺便分享一件早上发生的糗事。","text":"2020年元旦快乐！ 2020年第一天，给博客换了个logo，顺便分享一件早上发生的糗事。 早上起床，看外面有太阳，于是就想拿被子去顶楼晒一晒。我住11楼，顶楼在14楼。起床，扛上被子，进电梯，按14楼没反应，猛地反应过来电梯从今天起启用梯控卡。可是我没带，只好尴尬的随电梯到了一楼。在一楼扛着被子等了一会，没等到人上楼，迫不得已，自己扛着被子爬上了11楼…","categories":[{"name":"生活","slug":"生活","permalink":"http://hzyhbk.github.io/categories/生活/"}],"tags":[]},{"title":"echarts-for-react 修改点击图例事件","slug":"start/echarts-for-react修改点击图例事件","date":"2019-12-28T09:37:48.000Z","updated":"2019-12-28T10:05:55.128Z","comments":true,"path":"start/echarts-for-react修改点击图例事件/","link":"","permalink":"http://hzyhbk.github.io/start/echarts-for-react修改点击图例事件/","excerpt":"需求：点击图例，则选中该项，将其他项置灰；再次点击，恢复选中所有选项 做法：监听下legendselectchanged事件，用一个变量来保存上次点击的图例的名字， 如果点击的图例名称和保存的一致，说明是再次点击，应该恢复所有选项，把所有图例都置为 true; 如果点击的图例名称和保存的不一致，说明点击了另外的图例，这是需要更新变量，并且把这次点击的图例的selected设置为true，其他的设置为false。 坑点：如果在legendselectchanged里调用 echarts 的 dispatchActions，会陷入循环调用，如果还是想调用 dispatchActions方法，可参考这篇文章。我就直接调用setOption了。 监听 legendselectchanged 事件代码如下：","text":"需求：点击图例，则选中该项，将其他项置灰；再次点击，恢复选中所有选项 做法：监听下legendselectchanged事件，用一个变量来保存上次点击的图例的名字， 如果点击的图例名称和保存的一致，说明是再次点击，应该恢复所有选项，把所有图例都置为 true; 如果点击的图例名称和保存的不一致，说明点击了另外的图例，这是需要更新变量，并且把这次点击的图例的selected设置为true，其他的设置为false。 坑点：如果在legendselectchanged里调用 echarts 的 dispatchActions，会陷入循环调用，如果还是想调用 dispatchActions方法，可参考这篇文章。我就直接调用setOption了。 监听 legendselectchanged 事件代码如下：12345678910111213141516171819202122232425262728293031onLegendSelectChanged = (e: &#123; name: string; selected: &#123; [k: string]: boolean &#125;; &#125;) =&gt; &#123; let selected = Object.assign(&#123;&#125;, e.selected); // 用一个变量来保存上次点击的图例的名字 // 如果新点击的图例名称和保存的一致，说明是再次点击，应该恢复所有选项， // 就是把所有图例都置为true if (this.clickedLegendName === e.name) &#123; this.clickedLegendName = ''; Object.keys(selected).forEach(key =&gt; &#123; selected[key] = true; &#125;); &#125; else &#123; // 如果和保存的名称不一致，说明点击了另外的图例 // 更新clickedLegendName // 把这次点击的图例的selected设置为true，其他的设置为false this.clickedLegendName = e.name; Object.keys(selected).forEach(key =&gt; &#123; if (key === e.name) &#123; selected[key] = true; &#125; else &#123; selected[key] = false; &#125; &#125;); &#125; // 重新调用 getEchartsOption const option = this.getEchartsOption(selected); // 重新调用 setOption this.echartRef.setOption(option); &#125;; 组件完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import React, &#123; PureComponent &#125; from 'react';import _ from 'lodash';import styled from 'styled-components';import ReactEcharts from 'echarts-for-react';import moment from 'moment';const Root = styled.div``;type ILineChartProps = &#123; className?: string; style?: React.CSSProperties; rawData: &#123; data: IRawChartDataItem[]; series: &#123; name: string; data: number[]; type: 'line'; areaStyle: &#123;&#125;; &#125;[]; &#125;; loading: boolean;&#125;;type ILineChartState = &#123;&#125;;class LineChart extends PureComponent&lt;ILineChartProps, ILineChartState&gt; &#123; echartRef: any = null; clickedLegendName: string; getEchartsOption = (selected: &#123; [k: string]: boolean &#125; = &#123;&#125;) =&gt; &#123; const &#123; rawData: &#123; data, series &#125;, &#125; = this.props; const option = &#123; grid: &#123; top: 24, bottom: 8, left: 24, right: 36, containLabel: true, &#125;, legend: &#123; data: series.map(item =&gt; item.name), selected &#125;, tooltip: &#123; trigger: 'axis', formatter(params: any) &#123; let text = ''; if (_.isArray(params)) &#123; text = `$&#123;moment(Number(params[0].axisValue)).format( 'YYYY-MM-DD HH:mm:ss', )&#125;&lt;br/&gt;`; _.forEach(params, obj =&gt; &#123; let value = obj.value; text = `$&#123;text&#125;$&#123;obj.marker&#125;$&#123;obj.seriesName&#125;: $&#123;value&#125;&lt;br/&gt;`; &#125;); &#125; else &#123; text = `$&#123;moment(Number(params.axisValue)).format( 'YYYY-MM-DD HH:mm:ss', )&#125;&lt;br/&gt;`; text = `$&#123;text&#125;$&#123;params&#125;$&#123;params.seriesName&#125;: $&#123;params.value&#125;`; &#125; return text; &#125;, &#125;, xAxis: &#123; data: data.map(o =&gt; o.timestamp), axisLabel: &#123; formatter(value: string) &#123; return moment(Number(value)).format('HH:mm'); &#125;, &#125;, &#125;, yAxis: &#123; type: 'value', &#125;, series: series, &#125;; return option; &#125;; onLegendSelectChanged = (e: &#123; name: string; selected: &#123; [k: string]: boolean &#125;; &#125;) =&gt; &#123; let selected = Object.assign(&#123;&#125;, e.selected); if (this.clickedLegendName === e.name) &#123; this.clickedLegendName = ''; Object.keys(selected).forEach(key =&gt; &#123; selected[key] = true; &#125;); &#125; else &#123; this.clickedLegendName = e.name; Object.keys(selected).forEach(key =&gt; &#123; if (key === e.name) &#123; selected[key] = true; &#125; else &#123; selected[key] = false; &#125; &#125;); &#125; const option = this.getEchartsOption(selected); this.echartRef.setOption(option); &#125;; render() &#123; const &#123; className, style, loading &#125; = this.props; return ( &lt;Root className=&#123;className&#125; style=&#123;style&#125; &gt; &lt;ReactEcharts ref=&#123;(ref:any) =&gt; (this.echartRef = ref &amp;&amp; ref.getEchartsInstance())&#125; option=&#123;this.getEchartsOption()&#125; showLoading=&#123;loading&#125; onEvents=&#123;&#123; legendselectchanged: this.onLegendSelectChanged, &#125;&#125; /&gt; &lt;/Root&gt; ); &#125;&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://hzyhbk.github.io/categories/web前端/"}],"tags":[{"name":"echarts-for-react","slug":"echarts-for-react","permalink":"http://hzyhbk.github.io/tags/echarts-for-react/"}]},{"title":"Hello World","slug":"start/hello-world","date":"2018-12-29T16:00:00.000Z","updated":"2020-01-08T12:50:05.482Z","comments":true,"path":"start/hello-world/","link":"","permalink":"http://hzyhbk.github.io/start/hello-world/","excerpt":"Hello World 中文意思是『你好,世界』。因为《The C Programming Language》中使用它做为第一个演示程序，非常著名，所以后来的程序员在学习编程或进行设备调试时延续了这一习惯。 ——百度百科 我自己开始学写代码的时候，写的第一段代码也是Hello World, 所以我把它作为博客的第一篇文章。 控制台版本1console.log('Hello World')","text":"Hello World 中文意思是『你好,世界』。因为《The C Programming Language》中使用它做为第一个演示程序，非常著名，所以后来的程序员在学习编程或进行设备调试时延续了这一习惯。 ——百度百科 我自己开始学写代码的时候，写的第一段代码也是Hello World, 所以我把它作为博客的第一篇文章。 控制台版本1console.log('Hello World') React函数式组件版本123function() &#123; return &lt;div&gt;Hello World&lt;/div&gt;&#125; React类组件版本12345class Demo &#123; render() &#123; return &lt;div&gt;Hello World&lt;/div&gt; &#125;&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://hzyhbk.github.io/categories/web前端/"}],"tags":[{"name":"hello-world","slug":"hello-world","permalink":"http://hzyhbk.github.io/tags/hello-world/"}]}]}